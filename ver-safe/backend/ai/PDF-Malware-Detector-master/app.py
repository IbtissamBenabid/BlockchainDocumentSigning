from flask import Flask, request, jsonify
import joblib
import pandas as pd
import numpy as np
import re
import os
from PyPDF2 import PdfReader
import tempfile
import psycopg2
from datetime import datetime
import uuid
import logging
from functools import wraps

app = Flask(__name__)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Load model and scaler
try:
    model = joblib.load('pdf_malware_model.pkl')
    scaler = joblib.load('scaler.pkl')
    logger.info("AI models loaded successfully")
except FileNotFoundError:
    logger.error("Error: pdf_malware_model.pkl or scaler.pkl not found. Run train_model.py to generate them.")
    exit(1)

# Database configuration
DB_CONFIG = {
    'host': os.getenv('DB_HOST', 'postgres'),
    'port': os.getenv('DB_PORT', '5432'),
    'database': os.getenv('DB_NAME', 'versafe'),
    'user': os.getenv('DB_USER', 'versafe_user'),
    'password': os.getenv('DB_PASSWORD', 'versafe_password')
}

# API Key for inter-service communication
INTERNAL_API_KEY = os.getenv('INTERNAL_API_KEY', 'your-internal-api-key')

def get_db_connection():
    """Get database connection."""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        return conn
    except Exception as e:
        logger.error(f"Database connection error: {e}")
        return None

def authenticate_api_key(f):
    """Decorator for API key authentication."""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        api_key = request.headers.get('X-API-Key')
        if not api_key or api_key != INTERNAL_API_KEY:
            return jsonify({'error': 'Invalid or missing API key'}), 401
        return f(*args, **kwargs)
    return decorated_function

def extract_pdf_features(pdf_path):
    """Extract features from PDF using PyPDF2."""
    try:
        reader = PdfReader(pdf_path)
        metadata = reader.metadata or {}
        text_content = reader.pages[0].extract_text() if reader.pages else ""
        features = {
            'pdfsize': os.path.getsize(pdf_path) / 1024,  # Size in KB
            'metadata size': len(str(metadata)),
            'pages': len(reader.pages),
            'xref Length': 0,  # Not easily extracted with PyPDF2
            'isEncrypted': 1 if reader.is_encrypted else 0,
            'embedded files': 0,  # Requires custom parsing
            'images': 0,  # Requires custom parsing
            'text': 'Yes' if text_content else 'No',
            'header': metadata.get('/Producer', '%PDF-1.4'),  # Approximate header
            'obj': 0, 'endobj': 0, 'stream': 0, 'endstream': 0, 'xref': 0,
            'trailer': 0, 'startxref': 0, 'pageno': 0, 'encrypt': 0,
            'ObjStm': 0, 'Javascript': 0, 'AA': 0, 'OpenAction': 0,
            'Acroform': 0, 'JBIG2Decode': 0, 'RichMedia': 0, 'launch': 0,
            'EmbeddedFile': 0, 'XFA': 0, 'Colors': 0,
        }
        return features
    except Exception as e:
        print(f"Error extracting features: {e}")
        return None

def preprocess_features(features_dict):
    """Preprocess features to match training data."""
    df = pd.DataFrame([features_dict])
    
    # Apply preprocessing
    df['text'] = np.where(df['text'].str.contains('Yes'), 1, 0)
    df['header'] = df['header'].apply(lambda x: 1 if re.search(r'%PDF-\d*\.?\d*', x) else 0)
    df = df.fillna(0).replace([-1, -1.00], 0)
    
    # Ensure columns match training data
    expected_columns = ['pdfsize', 'metadata size', 'pages', 'xref Length', 'isEncrypted', 
                        'embedded files', 'images', 'text', 'header', 'obj', 'endobj', 
                        'stream', 'endstream', 'xref', 'trailer', 'startxref', 'pageno', 
                        'encrypt', 'ObjStm', 'Javascript', 'AA', 'OpenAction', 'Acroform', 
                        'JBIG2Decode', 'RichMedia', 'launch', 'EmbeddedFile', 'XFA', 'Colors']
    df = df.reindex(columns=expected_columns, fill_value=0)
    
    # Scale features
    scaled_features = scaler.transform(df)
    return scaled_features

def store_analysis_result(document_id, result, confidence, features):
    """Store AI analysis result in database."""
    try:
        conn = get_db_connection()
        if not conn:
            return False

        cursor = conn.cursor()
        analysis_id = str(uuid.uuid4())

        cursor.execute("""
            INSERT INTO ai_analysis (
                id, document_id, analysis_type, result, confidence_score,
                features_extracted, model_version, analysis_timestamp
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            analysis_id, document_id, 'MALWARE_SCAN', result, confidence,
            str(features), '1.0', datetime.now()
        ))

        conn.commit()
        cursor.close()
        conn.close()
        return True
    except Exception as e:
        logger.error(f"Failed to store analysis result: {e}")
        return False

@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint."""
    return jsonify({
        'status': 'healthy',
        'service': 'ai-service',
        'version': '1.0',
        'model_loaded': model is not None,
        'timestamp': datetime.now().isoformat()
    })

@app.route('/api/ai/scan-pdf', methods=['POST'])
@authenticate_api_key
def scan_pdf():
    """Enhanced PDF scanning with database integration."""
    try:
        # Check if file is provided
        if 'file' not in request.files:
            return jsonify({'error': 'No file provided'}), 400

        file = request.files['file']
        if not file.filename.endswith('.pdf'):
            return jsonify({'error': 'File must be a PDF'}), 400

        # Get document ID if provided
        document_id = request.form.get('document_id')

        # Save file temporarily
        with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf') as temp_file:
            file.save(temp_file.name)
            temp_path = temp_file.name

        # Extract features
        features = extract_pdf_features(temp_path)
        os.unlink(temp_path)  # Clean up temp file

        if features is None:
            return jsonify({'error': 'Failed to extract PDF features'}), 500

        # Preprocess and predict
        scaled_features = preprocess_features(features)
        prediction = model.predict(scaled_features)[0]
        confidence = float(model.predict_proba(scaled_features)[0].max())

        result = 'Malicious' if prediction == 1 else 'Benign'

        # Store result in database if document_id provided
        if document_id:
            store_analysis_result(document_id, result, confidence, features)

        response = {
            'success': True,
            'result': result,
            'confidence': confidence,
            'risk_score': int(confidence * 100),
            'features_analyzed': len(features),
            'analysis_timestamp': datetime.now().isoformat(),
            'model_version': '1.0'
        }

        logger.info(f"PDF scan completed: {result} (confidence: {confidence:.3f})")
        return jsonify(response)

    except Exception as e:
        logger.error(f"PDF scan error: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/ai/analyze-document/<document_id>', methods=['POST'])
@authenticate_api_key
def analyze_document(document_id):
    """Analyze a document by ID from the document service."""
    try:
        # Get document path from database or document service
        conn = get_db_connection()
        if not conn:
            return jsonify({'error': 'Database connection failed'}), 500

        cursor = conn.cursor()
        cursor.execute("SELECT file_path FROM documents WHERE id = %s", (document_id,))
        result = cursor.fetchone()
        cursor.close()
        conn.close()

        if not result:
            return jsonify({'error': 'Document not found'}), 404

        file_path = result[0]

        # Extract features and analyze
        features = extract_pdf_features(file_path)
        if features is None:
            return jsonify({'error': 'Failed to extract PDF features'}), 500

        scaled_features = preprocess_features(features)
        prediction = model.predict(scaled_features)[0]
        confidence = float(model.predict_proba(scaled_features)[0].max())

        result = 'Malicious' if prediction == 1 else 'Benign'

        # Store analysis result
        store_analysis_result(document_id, result, confidence, features)

        response = {
            'success': True,
            'document_id': document_id,
            'result': result,
            'confidence': confidence,
            'risk_score': int(confidence * 100),
            'features': features,
            'analysis_timestamp': datetime.now().isoformat()
        }

        return jsonify(response)

    except Exception as e:
        logger.error(f"Document analysis error: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/ai/analysis-history/<document_id>', methods=['GET'])
@authenticate_api_key
def get_analysis_history(document_id):
    """Get analysis history for a document."""
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({'error': 'Database connection failed'}), 500

        cursor = conn.cursor()
        cursor.execute("""
            SELECT id, analysis_type, result, confidence_score,
                   model_version, analysis_timestamp
            FROM ai_analysis
            WHERE document_id = %s
            ORDER BY analysis_timestamp DESC
        """, (document_id,))

        results = cursor.fetchall()
        cursor.close()
        conn.close()

        history = []
        for row in results:
            history.append({
                'id': row[0],
                'analysis_type': row[1],
                'result': row[2],
                'confidence_score': float(row[3]) if row[3] else 0,
                'model_version': row[4],
                'analysis_timestamp': row[5].isoformat() if row[5] else None
            })

        return jsonify({
            'success': True,
            'document_id': document_id,
            'history': history
        })

    except Exception as e:
        logger.error(f"Analysis history error: {e}")
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=8500)